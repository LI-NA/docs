(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{182:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),p=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},b=function(e){var t=p(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),b=p(n),m=a,u=b["".concat(o,".").concat(m)]||b[m]||d[m]||r;return n?i.a.createElement(u,s(s({ref:t},c),{},{components:n})):i.a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},94:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return p}));var a=n(3),i=n(7),r=(n(0),n(182)),o={slug:"encryption/",id:"encryption",title:"Encryption Protocol Specification v004",sidebar_label:"Encryption v004",description:"Specification for the Standard Notes end-to-end encryption.",keywords:["standard notes","docs","notes app","end-to-end encryption","encryption specification"],image:"/img/logo.png",hide_title:!1,hide_table_of_contents:!1},s={unversionedId:"specification/encryption",id:"specification/encryption",isDocsHomePage:!1,title:"Encryption Protocol Specification v004",description:"Specification for the Standard Notes end-to-end encryption.",source:"@site/docs/specification/encryption-004.md",sourceDirName:"specification",slug:"/specification/encryption/",permalink:"/specification/encryption/",editUrl:"https://github.com/standardnotes/docs/edit/main/docs/specification/encryption-004.md",version:"current",lastUpdatedAt:1612481815,formattedLastUpdatedAt:"2/4/2021",sidebar_label:"Encryption v004",frontMatter:{slug:"encryption/",id:"encryption",title:"Encryption Protocol Specification v004",sidebar_label:"Encryption v004",description:"Specification for the Standard Notes end-to-end encryption.",keywords:["standard notes","docs","notes app","end-to-end encryption","encryption specification"],image:"/img/logo.png",hide_title:!1,hide_table_of_contents:!1},sidebar:"technicalSidebar",previous:{title:"Publishing",permalink:"/extensions/publishing"},next:{title:"Encryption Protocol Specification v003",permalink:"/specification/encryption/003/"}},l=[{value:"Version 0.0.4",id:"version-004",children:[]},{value:"Introduction",id:"introduction",children:[]},{value:"Key Management",id:"key-management",children:[{value:"Key Generation Flow",id:"key-generation-flow",children:[]},{value:"Password change or protocol upgrade flow",id:"password-change-or-protocol-upgrade-flow",children:[]},{value:"Key Rotation",id:"key-rotation",children:[]}]},{value:"Encryption Flow",id:"encryption-flow",children:[]},{value:"Authentication",id:"authentication",children:[]},{value:"Root Key Wrapping",id:"root-key-wrapping",children:[]},{value:"Multi-Client Root Key Changes",id:"multi-client-root-key-changes",children:[{value:"Expired Sessions",id:"expired-sessions",children:[]}]},{value:"Storage",id:"storage",children:[{value:"Scenario A",id:"scenario-a",children:[]},{value:"Scenario B",id:"scenario-b",children:[]},{value:"Scenario C",id:"scenario-c",children:[]},{value:"Scenario D",id:"scenario-d",children:[]}]},{value:"003 Migration",id:"003-migration",children:[]},{value:"Cryptography Specifics",id:"cryptography-specifics",children:[{value:"Root Key Derivation Flow - Specifics",id:"root-key-derivation-flow---specifics",children:[]},{value:"Items Key Generation Flow",id:"items-key-generation-flow",children:[]},{value:"Encryption - Specifics",id:"encryption---specifics",children:[]},{value:"Encrypting a string using the 004 scheme:",id:"encrypting-a-string-using-the-004-scheme",children:[]}]},{value:"Next Steps",id:"next-steps",children:[]}],c={toc:l};function p(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"version-004"},"Version 0.0.4"),Object(r.b)("p",null,"The 004 protocol upgrade centers around a system that makes it easy and painless to upgrade to a future protocol version, as well as more modern cryptographic primitives."),Object(r.b)("p",null,"This page is a copy of the specification file located at ",Object(r.b)("a",{parentName:"p",href:"https://github.com/standardnotes/snjs/blob/master/packages/snjs/specification.md"},"github.com/standardnotes/snjs"),"."),Object(r.b)("h2",{id:"introduction"},"Introduction"),Object(r.b)("p",null,"The Standard Notes Protocol describes a set of procedures that ensure client-side encryption of data in such a way that makes it impossible for the server, which houses the data, to read or decrypt the data. It treats the server as a dumb data-store that simply saves and returns values on demand."),Object(r.b)("p",null,"Even in scenarios when the server is under active attack, clients should be fully protected, and cannot be tricked into revealing any sensitive information."),Object(r.b)("p",null,"The client and server communicate under two common procedures: authentication, and syncing."),Object(r.b)("p",null,'Authentication is a one-time transfer of information between client and server. In short, clients generate a long secret key by stretching a user-inputted password using a KDF. The first half of that key is kept locally as the "master key" and is never revealed to the server. The second half of that key is sent to the server as the "account server password".'),Object(r.b)("p",null,"The master key is then used to encrypt an arbitrary number of items keys. Items keys are generated randomly and not based on the account password. Items keys are used to encrypt syncable data, like notes, tags, and user preferences. Items keys themselves are also synced to user accounts, and are encrypted directly with the master key."),Object(r.b)("p",null,"When a user's master key changes, all items keys must be re-encrypted with the new master key. Accounts should generally have one items key per protocol version, so even in the event where many protocol upgrades are created, only a few KB of data must be re-encrypted when a user's credentials change (as opposed to completely re-encrypting many megabytes or gigabytes of data)."),Object(r.b)("p",null,"Data is also encrypted client-side for on-device storage. When an account is present, all local data is encrypted by default, including simple key-value storage (similar to a localStorage-like store). Persistence stores are always encrypted with the account master key, and the master key is stored in the device's secure keychain (when available)."),Object(r.b)("p",null,'Clients also have the option of configuring an application passcode, which wraps the account master key with an additional layer of encryption. Having a passcode enabled is referred to as having a "root key wrapper" enabled. When a root key is wrapped, it is stored in local storage as an encrypted payload, and the keychain is bypassed. This allows for secure key storage even in environments that don\'t expose a keychain, such as web browsers.'),Object(r.b)("p",null,"This document delineates client-side procedures for key management and generation, data encryption, and storage encryption. Concepts related to server syncing and server session management are outside the scope of this document. This document however wholly covers any values that a server would receive, so even though syncing and server session management is out of scope, the procedures outlined in this document should guarantee that no secret value is ever revealed to the server."),Object(r.b)("h2",{id:"key-management"},"Key Management"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"There are three main concepts as related to keys:")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"A root key"),"\u2014based on an account's user-inputted password. There exists only one root key per account."),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"A root key wrapper"),"\u2014",Object(r.b)("em",{parentName:"li"},"wraps"),' a root key (encrypts it) with an additional layer. This is a local-only construct, and translates directly as an "application passcode" feature.'),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Items keys"),"\u2014used to encrypt items. There can exist many items keys, and one items key can encrypt many items. Each items key is encrypted with the root key. When the root key changes, all items keys must be re-encrypted using the new root key.")),Object(r.b)("h3",{id:"key-generation-flow"},"Key Generation Flow"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"User registers with an email (",Object(r.b)("inlineCode",{parentName:"li"},"identifier"),") and a ",Object(r.b)("inlineCode",{parentName:"li"},"password"),"."),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"password")," is run through a KDF to generate a key, which is then split in two, as part of a single ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey"),".",Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},"The first half is the ",Object(r.b)("inlineCode",{parentName:"li"},"masterKey"),"."),Object(r.b)("li",{parentName:"ol"},"The second half is the ",Object(r.b)("inlineCode",{parentName:"li"},"serverPassword"),"."))),Object(r.b)("li",{parentName:"ol"},"Client registers user account with server using ",Object(r.b)("inlineCode",{parentName:"li"},"email")," and ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.serverPassword"),"."),Object(r.b)("li",{parentName:"ol"},"Client creates new random key ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey"),". This key is encrypted directly with ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.masterKey"),", and the encrypted ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," is assigned a UUID and uploaded to the user's account. (Each ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," is a traditional item, just like a note or tag.)")),Object(r.b)("h3",{id:"password-change-or-protocol-upgrade-flow"},"Password change or protocol upgrade flow"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"When a user changes their password, or when a new protocol version is available:")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Client generates new ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey")," using account identifier and password, and thus generates new ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.masterKey"),", ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.serverPassword"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"keyParams"),", which include the protocol version and other public information used to guide clients on generating the ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey")," given a user password."),Object(r.b)("li",{parentName:"ol"},"Client submits new ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.serverPassword")," and ",Object(r.b)("inlineCode",{parentName:"li"},"keyParams")," to server. Note that the changing the ",Object(r.b)("inlineCode",{parentName:"li"},"serverPassword")," does not necessarily invalidate a user's session. Sessions management is outside of the scope of this document."),Object(r.b)("li",{parentName:"ol"},"Client loops through all ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKeys")," and re-encrypts them with new ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey.masterKey"),". All ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKeys")," are then re-uploaded to server. Note that ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKeys")," are immutable and their inner key never changes. The key is only re-encrypted using the new ",Object(r.b)("inlineCode",{parentName:"li"},"masterKey"),".")),Object(r.b)("p",null,"This flow means that when a new protocol version is available or when a user changes their password, we do not need to re-encrypt all their data, but instead only a handful of keys."),Object(r.b)("h3",{id:"key-rotation"},"Key Rotation"),Object(r.b)("p",null,"By default, upgrading an account's protocol version will create a new ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," for that version, and that key will be used to encrypt all data going forward. To prevent large-scale data modification that may take hours to complete, any data encrypted with a previous ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," will be re-encrypted with the new ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," progressively, and not all at once. This progressive re-encryption occurs when an item is explicitly modified by the user. Applications can also be designed to bulk-modify items during idle-capacity, without user interaction."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"When changing the account password:")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"If a new protocol version is available, changing the account password will also upgrade to the latest protocol version and thus generates a new default ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey"),"."),Object(r.b)("li",{parentName:"ul"},"If no new protocol version is available, or if the user is already using the latest version, changing the account password generates a new ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey"),", as well as generates a new ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey"),". The new ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," will be used as the default items encryption key, and will also be used to progressively re-encrypt previous data. Generating a new ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," on password change ensures backward secrecy in the case the previous account password is compromised.")),Object(r.b)("h2",{id:"encryption-flow"},"Encryption Flow"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"For each")," item (such as a note) the client wants to encrypt:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Client generates random ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," (note: singular. Not related to ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey"),")."),Object(r.b)("li",{parentName:"ol"},"Client encrypts note content with ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," to form ",Object(r.b)("inlineCode",{parentName:"li"},"content"),"."),Object(r.b)("li",{parentName:"ol"},"Client encrypts ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," with default ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," as ",Object(r.b)("inlineCode",{parentName:"li"},"enc_item_key"),"."),Object(r.b)("li",{parentName:"ol"},"Client notes ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," UUID and associates it with encrypted item payload as ",Object(r.b)("inlineCode",{parentName:"li"},"items_key_id"),", and uploads payload to server.")),Object(r.b)("p",null,"To decrypt an item payload:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Client retrieves ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," matching ",Object(r.b)("inlineCode",{parentName:"li"},"items_key_id")," of payload."),Object(r.b)("li",{parentName:"ol"},"Client decrypts item's ",Object(r.b)("inlineCode",{parentName:"li"},"enc_item_key")," with ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," to form ",Object(r.b)("inlineCode",{parentName:"li"},"item_key"),"."),Object(r.b)("li",{parentName:"ol"},"Client decrypts item's ",Object(r.b)("inlineCode",{parentName:"li"},"content")," using ",Object(r.b)("inlineCode",{parentName:"li"},"item_key"),".")),Object(r.b)("h2",{id:"authentication"},"Authentication"),Object(r.b)("p",null,"Registering for an account involves generating a ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey")," and respective ",Object(r.b)("inlineCode",{parentName:"p"},"keyParams"),", according to the key generation flow above. The key parameters are uploaded to the server, and include:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"unique identifier (email)"),Object(r.b)("li",{parentName:"ul"},"salt seed"),Object(r.b)("li",{parentName:"ul"},"protocol version")),Object(r.b)("p",null,"To sign into an account, clients first make a request to the server to retrieve the key params for a given email. This endpoint is public and non-authenticated (unless the account has two-factor authentication enabled). The client then uses the retrieved key params to generate a ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey"),", and uses the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey.serverPassword")," to authenticate the account."),Object(r.b)("p",null,"Note that by default, the client trusts the protocol version the server reports. The client uses this protocol version to determine which cryptographic primitives (and their parameters) to use for key generation. This raises the question of, what happens if a malicious server underreports an account's version in order to weaken key generation parameters? For example, if a user's account is 004, but the server reports 002, the client will proceed to generate a ",Object(r.b)("inlineCode",{parentName:"p"},"serverPassword")," using outdated primitives."),Object(r.b)("p",null,"There are two safeguards against this scenario:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Older protocol versions are expired and become no longer supported after a certain period."),Object(r.b)("li",{parentName:"ol"},'Clients may sign in with a flag known as "strict sign in" (SSI). SSI ensures that the client ',Object(r.b)("em",{parentName:"li"},"always")," signs in with the client-side ",Object(r.b)("em",{parentName:"li"},"hardcoded latest version")," of the protocol. For example, if a client with SNJS 004 support attempts to sign in with SSI enabled, and the server reports a protocol version of 002 for a given account, the client will refuse this sign-in, and will not proceed with key generation. SSI is a user-controlled option. Clients cannot be programmed to default to SSI, as otherwise, users would be unable to sign in to their account whenever a new protocol version is available.")),Object(r.b)("h2",{id:"root-key-wrapping"},"Root Key Wrapping"),Object(r.b)("p",null,"Root key wrapping is a local-only construct that pertains to how the root key is stored locally. By default, and with no root key wrapping, the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey")," is stored in the secure device keychain. Only the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey.masterKey")," is stored locally; the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey.serverPassword")," is never stored locally, and is only used for initial account registration. If no keychain is available (web browsers), the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey")," is stored in storage in necessarily plain format."),Object(r.b)("p",null,"Root key wrapping allows the client to encrypt the ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey")," before storing it to disk. Wrapping a root key consists of:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},'Client asks user to choose a "local passcode".'),Object(r.b)("li",{parentName:"ol"},"The local passcode is run through the same key generation flow as account registration (using a random UUID as the account identifier, in place of an email) to generate a separate new root key known as the ",Object(r.b)("inlineCode",{parentName:"li"},"rootKeyWrappingKey")," (which likewise consists of a ",Object(r.b)("inlineCode",{parentName:"li"},"masterKey")," and an unused ",Object(r.b)("inlineCode",{parentName:"li"},"serverPassword"),")."),Object(r.b)("li",{parentName:"ol"},"The ",Object(r.b)("inlineCode",{parentName:"li"},"rootKeyWrappingKey")," is used to encrypt the ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey")," as ",Object(r.b)("inlineCode",{parentName:"li"},"wrappedRootKey"),". The ",Object(r.b)("inlineCode",{parentName:"li"},"wrappedRootKey")," (along with ",Object(r.b)("inlineCode",{parentName:"li"},"wrappingKeyKeyParams"),") is stored directly in storage, and the keychain is cleared of previous unwrapped ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey"),". (Some keychains have fixed payload size limit, so an encrypted payload may not always fit. For this reason ",Object(r.b)("inlineCode",{parentName:"li"},"wrappedRootKey")," is always stored directly in storage.)")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"To unwrap a root key:")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},'Client displays an "Enter your local passcode" prompt to user.'),Object(r.b)("li",{parentName:"ol"},"Client runs user-inputted password through key generation scheme (using stored ",Object(r.b)("inlineCode",{parentName:"li"},"wrappingKeyKeyParams"),") to generate a temporary ",Object(r.b)("inlineCode",{parentName:"li"},"rootKeyWrappingKey"),"."),Object(r.b)("li",{parentName:"ol"},"Client attempts to decrypt ",Object(r.b)("inlineCode",{parentName:"li"},"wrappedRootKey")," using ",Object(r.b)("inlineCode",{parentName:"li"},"rootKeyWrappingKey"),". If the decryption process succeeds (no errors are thrown), the client successfully unlocks application, and keeps the unwrapped ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey")," in application memory to aid in encryption and decryption of items (or rather ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKeys"),", to be exact).")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"The purpose of root key wrapping is many-fold:")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"To allow for secure storage of root key when no secure keychain is available (i.e web browsers)."),Object(r.b)("li",{parentName:"ol"},"Even in cases when a keychain is available, root key wrapping allows users to choose an arbitrary password to protect their storage with."),Object(r.b)("li",{parentName:"ol"},"To allow for encryption of local storage."),Object(r.b)("li",{parentName:"ol"},"To allow applications to introduce cryptographically-backed UI-level app locking.")),Object(r.b)("p",null,"When a root key is wrapped, no information about the wrapper is persisted locally or in memory beyond the ",Object(r.b)("inlineCode",{parentName:"p"},"keyParams")," for the wrapper. This includes any sort of hash for verification of the correctness of the entered local passcode. That is, when a user enters a local passcode, we know it is correct not because we compare one hash to another, but by whether it succeeds in decrypting some encrypted payload."),Object(r.b)("h2",{id:"multi-client-root-key-changes"},"Multi-Client Root Key Changes"),Object(r.b)("p",null,"Because account password changes (or, in general, root key changes) require all existing items keys to be re-encrypted with the new root key, it is possible that items keys eventually fall into an inconsistent state, such that some are encrypted with a newer root key, while others are encrypted with the new root key. Clients encountering an items key they cannot encrypt with the current account root key parameters would then reach a dead end, and users would see undecryptable data."),Object(r.b)("p",null,"To recover the ability to decrypt an items key, clients can use the ",Object(r.b)("inlineCode",{parentName:"p"},"kp")," (key params) included the items key's authenticated_data payload. These parameters represent the the key params of the root key used to encrypt this items key."),Object(r.b)("p",null,"For example, when the account password changes, and thus the root key changes, all items keys are re-encrypted with the new root key on client A. Another client (client B) who may have a valid API session, but an outdated root key, will be able to download these new items keys. However, when client B attempts to decrypt these keys using its root key, the decryption will fail. Client B enters a state where it can save items to the server (wherein those items are encrypted using its existing default readable items key), but cannot read new data encrypted with items keys encrypted with client A's root key."),Object(r.b)("p",null,"When client B connects to the API with a valid session token, but an outdated root key, it will be able to download new items keys, but not yet decrypt them. However, since the key parameters for the root key underlying the items key is included in the encrypted payload, the client will be able to prompt the user for their new password."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"In general,")),Object(r.b)("p",null,"A. When a client encounters an items key it cannot decrypt, whose created date is greater than any existing items key it has, it will:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Make an authenticated request to the server to retrieve the account's current key parameters (because we suspect that they may have changed, due to the above fact). Authenticated requests to the GET key_params endpoint bypasses the MFA requirement."),Object(r.b)("li",{parentName:"ol"},"Verify that the incoming key params version is greater than or equal to the client's current key params version. For example, if the client's key params version is 004, but the incoming key params version is 003, the client will reject these parameters as insecure and abort this process."),Object(r.b)("li",{parentName:"ol"},"Prompt the user for their account password, including in the prompt its reason. i.e ",Object(r.b)("em",{parentName:"li"},'"Your account password was changed 3 days ago. Enter your new account password."')),Object(r.b)("li",{parentName:"ol"},"Validate the account password based on its root key's ability to decrypt the aforementioned items key. If it succeeds, replace the client's current root key with this new root key.")),Object(r.b)("p",null,"At this point, this client is now in sync. It does not need to communicate with the server to handle updating its state after a password change."),Object(r.b)("p",null,"If the aforementioned items key's key params are not exactly equal to the server's key params (not a logical outcome, but assuming arbitrary desync), and no items keys exists with the same key params as the server key params, it must fallback to performing the regular sign in flow to authenticate its root key (based on its ",Object(r.b)("inlineCode",{parentName:"p"},"serverPassword")," field)."),Object(r.b)("p",null,"B. When a client encounters an items key it cannot decrypt, regardless of its created date, and the server key parameters are equal to the ones the client has on hand, this indicates that the items key may be encrypted with an older root key (for whatever reason)."),Object(r.b)("p",null,'In such cases, the client will present a "key recovery wizard", which all attempt to decrypt the stale items key:'),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Retrieve the key parameters associated with the authenticated_data of the items key's payload."),Object(r.b)("li",{parentName:"ol"},"Prompt the user for their account password as it was on the date the key parameters were created. For example, ",Object(r.b)("em",{parentName:"li"},'"Enter your account password as it was on Oct 20, 2019, 6:15AM."')),Object(r.b)("li",{parentName:"ol"},"Generate a root key from the account password using the relevant key params, and use that root key to decrypt the stale items key. If the decryption is successful, the client will then decrypt any items associated with that items key. It will then mark the key as needing sync."),Object(r.b)("li",{parentName:"ol"},"When the key subsequently runs through normal syncing logic, it will then proceed to be encrypted by the account's current root key, and synced to the account.")),Object(r.b)("p",null,'The above procedure represents a "corrective" course of action in the case that the sync following a root key change, where all items keys must be re-encrypted with the new root key, fails silently and results in inconsistent data.'),Object(r.b)("p",null,"Note that the difference between case A and case B is that in case A, we prompt the user for their account password and ",Object(r.b)("strong",{parentName:"p"},"update our client's root key")," with the generated root key, if it is valid. In case B, we generate a temporary root key for decryption purposes only, but discard of the root key after our decryption. This distinction is important because in case A, the server will be required to return key parameters with version greater than or equal to the user's current version, but in case B, key parameters can be arbitrarily old. However, because in this case the root key is not used for anything other than transient read operations, we can accept protocol versions no matter how outdated they are."),Object(r.b)("h3",{id:"expired-sessions"},"Expired Sessions"),Object(r.b)("p",null,"When a client encounters an invalid session network response (typically status code 498), it will:"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},'Retrieve the latest key parameters from the server. (Note that because GETting key parameters may require MFA authentication, clients must be prepared to handle an "mfa-required" error response.)'),Object(r.b)("li",{parentName:"ol"},"Ensure the key parameter version is greater than or equal to the version the client currently has on hand."),Object(r.b)("li",{parentName:"ol"},"Prompt the user for their account password, indicating the reason. i.e ",Object(r.b)("em",{parentName:"li"},'"Your session has expired. Please re-enter your account password to restore access to your account."')),Object(r.b)("li",{parentName:"ol"},"Proceed with normal sign in flow.")),Object(r.b)("h2",{id:"storage"},"Storage"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"There exists three types of storage:")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Value storage"),"\u2014values such as user preferences, session token, and other app-specific values."),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Payload storage"),"\u2014encrypted item payloads (such as notes and tags)."),Object(r.b)("li",{parentName:"ol"},Object(r.b)("strong",{parentName:"li"},"Root key storage"),"\u2014the primary root key.")),Object(r.b)("p",null,"How data is stored depends on different key scenarios."),Object(r.b)("h3",{id:"scenario-a"},"Scenario A"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"No root key and no root key wrapper (no account and no passcode)")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Value storage"),": Plain, unencrypted"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Payload storage"),": Plain, unencrypted"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Root key storage"),": Not applicable")),Object(r.b)("h3",{id:"scenario-b"},"Scenario B"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Root key but no root key wrapper (account but no passcode):")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Value storage"),": Encrypted with root key"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Payload storage:")," Encrypted with root key"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Root key storage"),":",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"With device keychain: Plainly in secure keychain"),Object(r.b)("li",{parentName:"ul"},"With no device keychain: Plainly in device storage")))),Object(r.b)("h3",{id:"scenario-c"},"Scenario C"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Root key and root key wrapper (account and passcode):")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Value storage"),": Encrypted with root key"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Payload storage"),": Encrypted with root key"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Root key storage"),": Encrypted in device storage")),Object(r.b)("h3",{id:"scenario-d"},"Scenario D"),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"No root key but root key wrapper (no account but passcode):")),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Value storage"),": Encrypted with root key wrapper"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Payload storage"),": Encrypted with root key wrapper"),Object(r.b)("li",{parentName:"ul"},Object(r.b)("strong",{parentName:"li"},"Root key storage"),": Not applicable")),Object(r.b)("h2",{id:"003-migration"},"003 Migration"),Object(r.b)("p",null,"For the most part, SNJS does not branch off into different modes of behavior for different protocol versions (apart from the version specific operators). This means that new constructs in 004, like items keys, are also used in 003. This is accomplished via migrations that are performed when the application detects older data state."),Object(r.b)("p",null,"In particular, when SNJS detects a pre-existing 003 account (before the user even has the chance to perform the protocol upgrade), a migration will be triggered that creates a default ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," using the account's current ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey.masterKey"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"itemsKey = { itemsKey: rootKey.masterKey, version: '003' }\n")),Object(r.b)("p",null,"This ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," is encrypted as usual using ",Object(r.b)("inlineCode",{parentName:"p"},"rootKey.masterKey"),", and synced to the user's account. When the user eventually performs the 004 upgrade (by entering their account password when prompted), a new ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," will be created as a default for 004. However, their previously created 003 ",Object(r.b)("inlineCode",{parentName:"p"},"itemsKey")," will continue to exist, so that data previously encrypted with 003 will still be decryptable."),Object(r.b)("h2",{id:"cryptography-specifics"},"Cryptography Specifics"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Key Derivation:")),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Name"),Object(r.b)("th",{parentName:"tr",align:null},"Value"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Algorithm"),Object(r.b)("td",{parentName:"tr",align:null},"Argon2id")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Memory (Bytes)"),Object(r.b)("td",{parentName:"tr",align:null},"67108864")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Iterations"),Object(r.b)("td",{parentName:"tr",align:null},"5")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Parallelism"),Object(r.b)("td",{parentName:"tr",align:null},"1")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Salt Length (Bits)"),Object(r.b)("td",{parentName:"tr",align:null},"128")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Output Key (Bits)"),Object(r.b)("td",{parentName:"tr",align:null},"512")))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Encryption:")),Object(r.b)("table",null,Object(r.b)("thead",{parentName:"table"},Object(r.b)("tr",{parentName:"thead"},Object(r.b)("th",{parentName:"tr",align:null},"Name"),Object(r.b)("th",{parentName:"tr",align:null},"Value"))),Object(r.b)("tbody",{parentName:"table"},Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Algorithm"),Object(r.b)("td",{parentName:"tr",align:null},"XChaCha20+Poly1305")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Key Length (Bits)"),Object(r.b)("td",{parentName:"tr",align:null},"256")),Object(r.b)("tr",{parentName:"tbody"},Object(r.b)("td",{parentName:"tr",align:null},"Nonce Length (Bits)"),Object(r.b)("td",{parentName:"tr",align:null},"192")))),Object(r.b)("h3",{id:"root-key-derivation-flow---specifics"},"Root Key Derivation Flow - Specifics"),Object(r.b)("p",null,"Given a user ",Object(r.b)("inlineCode",{parentName:"p"},"identifier")," (email) and ",Object(r.b)("inlineCode",{parentName:"p"},"password")," (user password):"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Generate a random salt ",Object(r.b)("inlineCode",{parentName:"li"},"seed"),", 256 bits (",Object(r.b)("inlineCode",{parentName:"li"},"hex"),")."),Object(r.b)("li",{parentName:"ol"},"Generate ",Object(r.b)("inlineCode",{parentName:"li"},"salt"),":",Object(r.b)("ol",{parentName:"li"},Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"hash = SHA256Hex('identifier:seed')")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("inlineCode",{parentName:"li"},"salt = hash.substring(0, 32)")))),Object(r.b)("li",{parentName:"ol"},"Generate ",Object(r.b)("inlineCode",{parentName:"li"},"derivedKey = argon2(password, salt, ITERATIONS, MEMORY, OUTPUT_LENGTH) ")),Object(r.b)("li",{parentName:"ol"},"Generate ",Object(r.b)("inlineCode",{parentName:"li"},"rootKey")," as:",Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"}," {\n   masterKey: derivedKey.firstHalf,\n   serverPassword: derivedKey.secondHalf,\n   version: '004'\n }\n"))),Object(r.b)("li",{parentName:"ol"},"For account registration, ",Object(r.b)("inlineCode",{parentName:"li"},"identifier"),", ",Object(r.b)("inlineCode",{parentName:"li"},"seed"),", ",Object(r.b)("inlineCode",{parentName:"li"},"serverPassword"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"version")," must be uploaded to the server.")),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Understanding the salt ",Object(r.b)("inlineCode",{parentName:"strong"},"seed"),":")),Object(r.b)("p",null,"Our threat model is intended to distrust the server as much as possible. For this reason, we do not want to blindly trust whatever salt value a server returns to us. For example, a malicious server may attempt to mass-weaken user security by sending the same salt for every user account, and observe what interesting results the clients send back. Instead, clients play a more significant role in salt generation, and use the value the user inputs into the email field for salt generation."),Object(r.b)("p",null,"At this point we have ",Object(r.b)("inlineCode",{parentName:"p"},"salt = generateSalt(email)"),". However, we'd ideally like to make this value more unique. Emails are globally unique, but well-known in advance. We could introduce more variability by also including the protocol version in salt computation, such as ",Object(r.b)("inlineCode",{parentName:"p"},"salt = generateSalt(email, version)"),", but this could also be well-accounted for in advance."),Object(r.b)("p",null,"The salt ",Object(r.b)("inlineCode",{parentName:"p"},"seed")," serves as a way to make it truly impossible to know a salt for an account ahead of time, without first interacting with the server the account is hosted on. While retrieving a ",Object(r.b)("inlineCode",{parentName:"p"},"seed")," for a given account is a public, non-authorized operation, users who configure two-factor authentication can proceed to lock this operation so that a proper 2FA code is required to retrieve the salt ",Object(r.b)("inlineCode",{parentName:"p"},"seed"),". Salts are thus computed via ",Object(r.b)("inlineCode",{parentName:"p"},"salt = generateSalt(email, seed)"),"."),Object(r.b)("h3",{id:"items-key-generation-flow"},"Items Key Generation Flow"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Generate random ",Object(r.b)("inlineCode",{parentName:"li"},"hex")," string ",Object(r.b)("inlineCode",{parentName:"li"},"key"),", 256 bits."),Object(r.b)("li",{parentName:"ol"},"Create ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey = {itemsKey: key, version: '004'}"))),Object(r.b)("h3",{id:"encryption---specifics"},"Encryption - Specifics"),Object(r.b)("p",null,"An encrypted payload consists of:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"items_key_id"),": The UUID of the ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey")," used to encrypt ",Object(r.b)("inlineCode",{parentName:"li"},"enc_item_key"),"."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"enc_item_key"),": An encrypted protocol string joined by colons ",Object(r.b)("inlineCode",{parentName:"li"},":")," of the following components:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"protocol version"),Object(r.b)("li",{parentName:"ul"},"encryption nonce"),Object(r.b)("li",{parentName:"ul"},"ciphertext"),Object(r.b)("li",{parentName:"ul"},"authenticated_data"))),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"content"),": An encrypted protocol string joined by colons ",Object(r.b)("inlineCode",{parentName:"li"},":")," of the following components:",Object(r.b)("ul",{parentName:"li"},Object(r.b)("li",{parentName:"ul"},"protocol version"),Object(r.b)("li",{parentName:"ul"},"encryption nonce"),Object(r.b)("li",{parentName:"ul"},"ciphertext"),Object(r.b)("li",{parentName:"ul"},"authenticated_data")))),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Procedure to encrypt an item (such as a note):")),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},"Generate a random 256-bit key ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," (in ",Object(r.b)("inlineCode",{parentName:"li"},"hex")," format)."),Object(r.b)("li",{parentName:"ol"},"Encrypt ",Object(r.b)("inlineCode",{parentName:"li"},"item.content")," using ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," to form ",Object(r.b)("inlineCode",{parentName:"li"},"content"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"{ u: item.uuid, v: '004', kp: rootKey.key_params IF item.type == ItemsKey }")," as ",Object(r.b)("inlineCode",{parentName:"li"},"authenticated_data"),", following the instructions ",Object(r.b)("em",{parentName:"li"},'"Encrypting a string using the 004 scheme"')," below."),Object(r.b)("li",{parentName:"ol"},"Encrypt ",Object(r.b)("inlineCode",{parentName:"li"},"item_key")," using the the default ",Object(r.b)("inlineCode",{parentName:"li"},"itemsKey.itemsKey")," to form ",Object(r.b)("inlineCode",{parentName:"li"},"enc_item_key"),", and ",Object(r.b)("inlineCode",{parentName:"li"},"{ u: item.uuid, v: '004', kp: rootKey.key_params IF item.type == ItemsKey }")," as ",Object(r.b)("inlineCode",{parentName:"li"},"authenticated_data"),", following the instructions ",Object(r.b)("em",{parentName:"li"},'"Encrypting a string using the 004 scheme"')," below."),Object(r.b)("li",{parentName:"ol"},"Generate an encrypted payload as:",Object(r.b)("pre",{parentName:"li"},Object(r.b)("code",{parentName:"pre"},"{\n    items_key_id: itemsKey.uuid,\n    enc_item_key: enc_item_key,\n    content: content,\n}\n")))),Object(r.b)("h3",{id:"encrypting-a-string-using-the-004-scheme"},"Encrypting a string using the 004 scheme:"),Object(r.b)("p",null,"Given a ",Object(r.b)("inlineCode",{parentName:"p"},"string_to_encrypt"),", an ",Object(r.b)("inlineCode",{parentName:"p"},"encryption_key"),", ",Object(r.b)("inlineCode",{parentName:"p"},"authenticated_data"),", and an item's ",Object(r.b)("inlineCode",{parentName:"p"},"uuid"),":"),Object(r.b)("ol",null,Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Generate a random 192-bit string called ",Object(r.b)("inlineCode",{parentName:"p"},"nonce"),".")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Encode ",Object(r.b)("inlineCode",{parentName:"p"},"authenticated_data")," as a base64 encoded json string (",Object(r.b)("inlineCode",{parentName:"p"},"base64(json(authenticated_data))"),") where the embedded data is recursively sorted by key for stringification (i.e ",Object(r.b)("inlineCode",{parentName:"p"},"{v: '2', 'u': '1'}")," should be stringified as ",Object(r.b)("inlineCode",{parentName:"p"},"{u: '1', 'v': '2'}"),"), to get ",Object(r.b)("inlineCode",{parentName:"p"},"encoded_authenticated_data"),".")),Object(r.b)("li",{parentName:"ol"},Object(r.b)("p",{parentName:"li"},"Encrypt ",Object(r.b)("inlineCode",{parentName:"p"},"string_to_encrypt")," using ",Object(r.b)("inlineCode",{parentName:"p"},"XChaCha20+Poly1305:Base64"),", ",Object(r.b)("inlineCode",{parentName:"p"},"encryption_key"),", ",Object(r.b)("inlineCode",{parentName:"p"},"nonce"),", and ",Object(r.b)("inlineCode",{parentName:"p"},"encoded_authenticated_data"),":"))),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"ciphertext = XChaCha20Poly1305(string_to_encrypt, encryption_key, nonce, encoded_authenticated_data)\n")),Object(r.b)("ol",{start:4},Object(r.b)("li",{parentName:"ol"},"Generate the final result by combining components into a ",Object(r.b)("inlineCode",{parentName:"li"},":")," separated string:")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre"},"result = ['004', nonce, ciphertext, encoded_authenticated_data].join(':')\n")),Object(r.b)("h2",{id:"next-steps"},"Next Steps"),Object(r.b)("p",null,"Join the ",Object(r.b)("a",{parentName:"p",href:"https://standardnotes.org/slack"},"Slack group")," to discuss implementation details and ask any questions you may have."),Object(r.b)("p",null,"You can also email ",Object(r.b)("a",{parentName:"p",href:"mailto:help@standardnotes.org"},"help@standardnotes.org"),"."),Object(r.b)("p",null,"Follow ",Object(r.b)("a",{parentName:"p",href:"https://twitter.com/standardnotes"},"@standardnotes on Twitter")," for updates and announcements."))}p.isMDXComponent=!0}}]);